<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>T·∫°o Nh√¢n V·∫≠t AI ‚Äî 3 Ch·∫ø ƒê·ªô</title>
  <style>
    body{font-family:"Segoe UI",sans-serif;background:linear-gradient(135deg,#1e3c72,#2a5298);color:white;margin:0;padding:20px;text-align:center}
    h1{font-size:2em;margin-bottom:10px}
    .mode-select{display:flex;justify-content:center;gap:10px;margin:20px auto;flex-wrap:wrap}
    .opt{padding:12px 20px;border-radius:10px;background:rgba(255,255,255,0.1);cursor:pointer;transition:.2s;border:1px solid rgba(255,255,255,0.2)}
    .opt.active{background:#ff6b6b}
    .pane{display:none;margin-top:20px}
    .pane.show{display:block}
    input,select,button{padding:10px;margin:6px;border:none;border-radius:8px;font-size:1em}
    button{background:#ff6b6b;color:white;cursor:pointer}
    button:hover{background:#ff5252}
    iframe{width:100%;height:70vh;border-radius:12px;border:none}
    .status{margin-top:10px;font-style:italic;color:#ffd93d}
    img{max-width:100%;border-radius:10px;margin-top:20px;box-shadow:0 6px 20px rgba(0,0,0,0.4)}
  </style>
</head>
<body>

  <h1>üßô‚Äç‚ôÇÔ∏è T·∫°o Nh√¢n V·∫≠t Fantasy (3 ch·∫ø ƒë·ªô)</h1>

  <div class="mode-select" id="modeSelect">
    <div class="opt" data-mode="free">Mi·ªÖn ph√≠</div>
    <div class="opt" data-mode="hf">HuggingFace API</div>
    <div class="opt" data-mode="replicate">Replicate API</div>
  </div>

  <!-- MODE 1: FREE -->
  <div id="paneFree" class="pane show">
    <p>D√πng Hugging Face Space mi·ªÖn ph√≠ (iframe, kh√¥ng c·∫ßn API).</p>
   <div id="freeWrap">
  <iframe id="freeIframe"
    src="https://hf.space/embed/hysts/SDXL/+/ ?__theme=light"
    title="HF Free Space"
    style="width:100%;height:70vh;border:none;border-radius:12px">
  </iframe>
  <div id="freeFallback" class="status" style="display:none;margin-top:8px">
    Kh√¥ng nh√∫ng ƒë∆∞·ª£c Space. <a id="freeOpen" target="_blank" rel="noopener">M·ªü trong tab m·ªõi</a>
  </div>
</div>

<script>
  (function() {
    const url = "https://hf.space/embed/hysts/SDXL/+/ ?__theme=light";
    const iframe = document.getElementById("freeIframe");
    const fb = document.getElementById("freeFallback");
    const open = document.getElementById("freeOpen");
    open.href = url;

    // N·∫øu 6 gi√¢y kh√¥ng load xong ‚Üí coi nh∆∞ fail (do XFO/CSP, 404‚Ä¶)
    const t = setTimeout(() => {
      fb.style.display = "block";
    }, 6000);

    iframe.addEventListener("load", () => clearTimeout(t));
  })();
</script>


  </div>

  <!-- MODE 2: HUGGING FACE API -->
  <div id="paneHF" class="pane">
    <p>G·ªçi tr·ª±c ti·∫øp model qua Hugging Face API (token hf_...)</p>
    <input type="text" id="hfPrompt" placeholder="VD: c√¥ g√°i t√≥c tr·∫Øng, √°nh s√°ng huy·ªÅn ·∫£o..." size="50"/>
    <br>
    <button onclick="generateHF()">T·∫°o ·∫¢nh (HF)</button>
    <div id="hfStatus" class="status"></div>
    <div id="hfResult"></div>
  </div>

  <!-- MODE 3: REPLICATE -->
  <div id="paneReplicate" class="pane">
    <p>G·ªçi Replicate API (token r8_...) - ch·∫•t l∆∞·ª£ng cao.</p>
    <input type="text" id="repPrompt" placeholder="VD: nh√¢n v·∫≠t nam phong c√°ch Pixar, √°o gi√°p v√†ng..." size="50"/>
    <br>
    <button onclick="generateReplicate()">T·∫°o ·∫¢nh (Replicate)</button>
    <div id="repStatus" class="status"></div>
    <div id="repResult"></div>
  </div>

  <script>
    // === Mode switching ===
    const modes = document.querySelectorAll(".opt");
    const panes = {
      free: document.getElementById("paneFree"),
      hf: document.getElementById("paneHF"),
      replicate: document.getElementById("paneReplicate")
    };
    modes.forEach(opt=>{
      opt.addEventListener("click",()=>{
        modes.forEach(o=>o.classList.remove("active"));
        opt.classList.add("active");
        const mode = opt.dataset.mode;
        Object.keys(panes).forEach(k=>panes[k].classList.toggle("show",k===mode));
      });
    });
    modes[0].classList.add("active");

    // === Hugging Face API (s·ª≠a URL + ƒë·ªçc ·∫£nh/binary/JSON) ===
async function generateHF() {
  const prompt = document.getElementById("hfPrompt").value.trim();
  if (!prompt) { alert("Nh·∫≠p m√¥ t·∫£!"); return; }

  const status = document.getElementById("hfStatus");
  const result = document.getElementById("hfResult");
  status.textContent = "‚è≥ ƒêang t·∫°o ·∫£nh (HuggingFace)...";
  result.innerHTML = "";

  try {
    const resp = await fetch("/api/hf-proxy", {              // üëà ƒë·ªïi sang /api/...
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: "black-forest-labs/FLUX.1.1-pro",
        input: { inputs: prompt }                             // HF th∆∞·ªùng d√πng key "inputs"
      })
    });

    if (!resp.ok) {
      // l·ªói HTTP nh∆∞ng body c√≥ th·ªÉ v·∫´n l√† JSON b√°o l·ªói
      const msg = await resp.text();
      throw new Error(`HTTP ${resp.status} ‚Äî ${msg.slice(0, 300)}`);
    }

    const ct = (resp.headers.get("content-type") || "").toLowerCase();
    if (ct.startsWith("image/")) {
      // Proxy tr·∫£ ·∫£nh binary
      const blob = await resp.blob();
      const url = URL.createObjectURL(blob);
      status.textContent = "‚úÖ Ho√†n t·∫•t!";
      result.innerHTML = `<img src="${url}" alt="HF result"/>`;
      return;
    }

    // Kh√¥ng ph·∫£i image ‚Üí ƒë·ªçc text, th·ª≠ parse JSON
    const text = await resp.text();
    try {
      const data = JSON.parse(text);
      if (data.error) throw new Error(data.error);
      // M·ªôt s·ªë model/adapter tr·∫£ v·ªÅ output d·∫°ng m·∫£ng URL
      const url = data.url || data.output?.[0];
      if (url) {
        status.textContent = "‚úÖ Ho√†n t·∫•t!";
        result.innerHTML = `<img src="${url}" alt="HF result"/>`;
      } else {
        // fallback: n·∫øu tr·∫£ v·ªÅ data URL
        if (text.startsWith("data:")) {
          status.textContent = "‚úÖ Ho√†n t·∫•t!";
          result.innerHTML = `<img src="${text}" alt="HF result"/>`;
        } else {
          throw new Error("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ·∫£nh t·ª´ HF.");
        }
      }
    } catch {
      // Kh√¥ng ph·∫£i JSON: c√≥ th·ªÉ l√† dataURL (base64) ho·∫∑c text thu·∫ßn
      if (text.startsWith("data:")) {
        status.textContent = "‚úÖ Ho√†n t·∫•t!";
        result.innerHTML = `<img src="${text}" alt="HF result"/>`;
      } else {
        throw new Error(text.slice(0, 300));
      }
    }
  } catch (e) {
    status.textContent = "‚ùå L·ªói: " + e.message;
  }
}


   // === Replicate API (ƒë·ªïi URL sang /api/...) ===
async function generateReplicate() {
  const prompt = document.getElementById("repPrompt").value.trim();
  if (!prompt) { alert("Nh·∫≠p m√¥ t·∫£!"); return; }

  const status = document.getElementById("repStatus");
  const result = document.getElementById("repResult");
  status.textContent = "‚è≥ ƒêang g·ª≠i y√™u c·∫ßu Replicate...";
  result.innerHTML = "";

  try {
    const start = await fetch("/api/replicate-proxy", {      // üëà ƒë·ªïi sang /api/...
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: "black-forest-labs/flux-1.1-pro",
        input: { prompt }
      })
    });
    if (!start.ok) throw new Error("HTTP " + start.status);
    const job = await start.json();

    let data = job;
    while (["starting", "processing", "queued"].includes(data.status)) {
      await new Promise(r => setTimeout(r, 2000));
      const poll = await fetch("/api/replicate-get?id=" + job.id);  // üëà ƒë·ªïi sang /api/...
      data = await poll.json();
    }

    if (data.status !== "succeeded") throw new Error(data.error || "Job fail");
    status.textContent = "‚úÖ Ho√†n t·∫•t!";
    const url = Array.isArray(data.output) ? data.output[0] : data.output;
    result.innerHTML = `<img src="${url}" alt="Replicate result"/>`;
  } catch (e) {
    status.textContent = "‚ùå L·ªói: " + e.message;
  }
}
// ====== Fallback Orchestrator ======
// C·∫•u h√¨nh
const FALLBACK_ORDER = ["hf", "replicate", "free"]; // th·ª© t·ª± d·ª± ph√≤ng
const MODE_LABEL = { hf: "Hugging Face API", replicate: "Replicate API", free: "Mi·ªÖn ph√≠ (Space)" };
const PER_STEP_TIMEOUT_MS = 20000; // 20s/ ch·∫ø ƒë·ªô, b·∫°n ch·ªânh t√πy √Ω

// Helper timeout Promise
function withTimeout(promise, ms, label = "timeout") {
  return Promise.race([
    promise,
    new Promise((_, reject) => setTimeout(() => reject(new Error(label)), ms))
  ]);
}

// G√≥i l·∫°i 2 h√†m hi·ªán c√≥ th√†nh Promise tr·∫£ v·ªÅ URL ·∫£nh (n·∫øu th√†nh c√¥ng)
async function tryHF(prompt) {
  // G·∫ßn nh∆∞ b·∫£n generateHF nh∆∞ng tr·∫£ v·ªÅ URL ·∫£nh, n√©m Error khi l·ªói
  const resp = await fetch("/api/hf-proxy", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      model: "stabilityai/sdxl-turbo", // ∆∞u ti√™n model nhanh/nh·∫π cho free-tier
      input: { inputs: prompt, num_inference_steps: 6, guidance_scale: 0 }
    })
  });
  if (!resp.ok) {
    const msg = await resp.text();
    throw new Error(`HF HTTP ${resp.status} ‚Äî ${msg.slice(0,200)}`);
  }
  const ct = (resp.headers.get("content-type") || "").toLowerCase();
  if (ct.startsWith("image/")) {
    const blob = await resp.blob();
    return URL.createObjectURL(blob);
  }
  const text = await resp.text();
  try {
    const data = JSON.parse(text);
    const url = data.url || (Array.isArray(data.output) ? data.output[0] : data.output);
    if (!url) throw new Error(data.error || "HF kh√¥ng tr·∫£ URL ·∫£nh");
    return url;
  } catch {
    if (text.startsWith("data:")) return text;
    throw new Error(text.slice(0,200));
  }
}

async function tryReplicate(prompt) {
  const start = await fetch("/api/replicate-proxy", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      model: "black-forest-labs/flux-1.1-pro",
      input: { prompt, aspect_ratio: "1:1", output_format: "png" }
    })
  });
  if (!start.ok) throw new Error(`Replicate start HTTP ${start.status}`);
  const job = await start.json();

  let data = job, tries = 0;
  while (["starting", "processing", "queued"].includes(data.status)) {
    await new Promise(r => setTimeout(r, 1500));
    const r = await fetch("/api/replicate-get?id=" + job.id);
    if (!r.ok) throw new Error("Replicate poll fail");
    data = await r.json();
    if (++tries > 180) throw new Error("Replicate timeout");
  }
  if (data.status !== "succeeded") throw new Error(data.error || "Replicate job fail");
  const url = Array.isArray(data.output) ? data.output[0] : data.output;
  if (!url) throw new Error("Replicate kh√¥ng tr·∫£ URL ·∫£nh");
  return url;
}

// Hi·ªÉn th·ªã ·∫£nh v√†o kh·ªëi k·∫øt qu·∫£ hi·ªán c√≥ (∆∞u ti√™n pane ƒëang m·ªü)
function showImage(url) {
  // ∆∞u ti√™n render v√†o HF pane n·∫øu ƒëang m·ªü, ng∆∞·ª£c l·∫°i th·ª≠ Replicate pane
  const targets = [
    document.getElementById("hfResult"),
    document.getElementById("repResult")
  ].filter(Boolean);

  targets.forEach(el => el.innerHTML = ""); // clear
  const el = targets.find(t => t.closest(".pane").classList.contains("show")) || targets[0] || document.body;
  el.innerHTML = `<img src="${url}" alt="AI result"/>` +
                 `<div class="status" style="margin-top:6px">Ngu·ªìn ·∫£nh: ${url.includes("blob:") ? "Hugging Face" : (url.includes("replicate") ? "Replicate" : "AI")}</div>`;
}

// B·∫≠t pane theo key
function switchPane(modeKey) {
  const panesMap = { free: paneFree, hf: paneHF, replicate: paneReplicate };
  Object.entries(panesMap).forEach(([k, node]) => node && node.classList.toggle("show", k === modeKey));
  // t√¥ active button
  document.querySelectorAll(".opt").forEach(o => o.classList.toggle("active", o.dataset.mode === modeKey));
}

// Orchestrator: th·ª≠ l·∫ßn l∆∞·ª£t theo FALLBACK_ORDER
async function generateAuto() {
  const autoStatus = document.getElementById("autoStatus");
  const prompt = (document.getElementById("hfPrompt") || document.getElementById("repPrompt")).value.trim();
  if (!prompt) { alert("Nh·∫≠p m√¥ t·∫£ tr∆∞·ªõc ƒë√£ nh√©!"); return; }

  autoStatus.textContent = "B·∫Øt ƒë·∫ßu (Auto)‚Ä¶";
  // Xo√° k·∫øt qu·∫£ c≈©
  const hfRes = document.getElementById("hfResult"); if (hfRes) hfRes.innerHTML = "";
  const rpRes = document.getElementById("repResult"); if (rpRes) rpRes.innerHTML = "";

  const errors = [];
  for (const mode of FALLBACK_ORDER) {
    try {
      autoStatus.textContent = `ƒêang th·ª≠: ${MODE_LABEL[mode]}‚Ä¶`;
      if (mode === "free") {
        // Free kh√¥ng th·ªÉ t·ª± sinh ·∫£nh qua code ‚Üí b·∫≠t tab Free ƒë·ªÉ b·∫°n thao t√°c th·ªß c√¥ng
        switchPane("free");
        autoStatus.textContent = "ƒê√£ chuy·ªÉn sang Mi·ªÖn ph√≠ (Space). H√£y d√πng khung iframe ƒë·ªÉ t·∫°o ·∫£nh.";
        return;
      }
      // hf / replicate c√≥ th·ªÉ t·ª± sinh
      const run = mode === "hf" ? tryHF(prompt) : tryReplicate(prompt);
      const url = await withTimeout(run, PER_STEP_TIMEOUT_MS, "Qu√° th·ªùi gian ch·ªù");
      showImage(url);
      autoStatus.textContent = `‚úÖ Th√†nh c√¥ng v·ªõi ${MODE_LABEL[mode]}`;
      // b·∫≠t pane t∆∞∆°ng ·ª©ng
      switchPane(mode);
      return;
    } catch (e) {
      errors.push(`${mode}: ${e.message || e}`);
      autoStatus.textContent = `‚ö†Ô∏è Th·∫•t b·∫°i ·ªü ${MODE_LABEL[mode]} ‚Äî th·ª≠ ch·∫ø ƒë·ªô k·∫ø ti·∫øp‚Ä¶`;
    }
  }
  autoStatus.textContent = "‚ùå T·∫•t c·∫£ ch·∫ø ƒë·ªô ƒë·ªÅu l·ªói.\n" + errors.join(" | ");
}

// G·∫Øn s·ª± ki·ªán cho n√∫t Auto (n·∫øu b·∫°n ƒë√£ th√™m)
const btnAuto = document.getElementById("btnAuto");
if (btnAuto) btnAuto.addEventListener("click", generateAuto);

  </script>
</body>
</html>


