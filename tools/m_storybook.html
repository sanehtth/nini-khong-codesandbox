<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NiNi — Storybook Editor (Whole-Book Manifest + Next ID)</title>

  <style>
    html, body { margin:0; padding:0; height:100%; }
    body { color:#fff; font:15px/1.6 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    body::before{
      content:""; position:fixed; inset:0; z-index:-1;
      background: url("/public/assets/bg/nini_home.webp") center/cover no-repeat;
      filter: blur(5px);
    }
    .editor-content{ max-width: 980px; margin: 0 auto; padding: 24px 16px 72px; }
    .section{ margin-bottom: 24px; }
    h2{ margin: 0 0 12px; }
    h3{ margin: 12px 0 8px; font-size: 1.08rem; }

    label{ display:block; margin-bottom:6px; opacity:.9 }
    input, textarea{
      width:100%; padding:8px 0; border:0; border-bottom:1px solid #fff;
      background:transparent; color:#fff; margin-bottom:14px; font:inherit;
    }
    input:focus, textarea:focus{ outline:none; border-bottom:2px solid #fff; }
    textarea{ resize:vertical; min-height: 80px; }

    .row{ display:flex; flex-wrap:wrap; align-items:center; gap:8px; }
    .btn{
      background:transparent; color:#fff; border:1px solid #fff;
      padding:8px 14px; border-radius:6px; cursor:pointer;
    }
    .btn:hover{ background:#fff; color:#000; }
    .btn.danger{ border-color:#ffb0b0; color:#ffb0b0; }
    .btn.danger:hover{ background:#ffb0b0; color:#2a0a0a; }

    .select{
      border:1px solid #fff; padding:6px 10px; border-radius:6px;
      background:transparent; color:#fff;
    }
    .select:focus{ outline:none; border-width:2px; }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 860px){ .grid{ grid-template-columns: 1fr; } }

    .page-entry{
      border:1px dashed rgba(255,255,255,.35);
      padding:12px; border-radius:8px; margin-bottom:14px;
      background: rgba(0,0,0,.15);
    }
    .page-head{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px; }

    pre{
      white-space:pre-wrap; background:rgba(0,0,0,.35);
      padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,.25);
      max-height: 50vh; overflow:auto;
    }
    .muted{ opacity:.85; }
    .hr { height:1px; background:rgba(255,255,255,.3); margin:10px 0; }
  </style>
</head>
<body>
  <div class="editor-content">

    <!-- BOOK META -->
    <div class="section">
      <h2>Thông tin Sách</h2>
      <label>ID Sách</label>
      <input id="bookId" placeholder="VD: B001"/>
      <label>Tiêu đề (VI)</label>
      <input id="titleVi" placeholder="NiNi và khu rừng"/>
      <label>Tiêu đề (EN)</label>
      <input id="titleEn" placeholder="NiNi in the Forest"/>
      <label>Tác giả</label>
      <input id="author" placeholder="Tên tác giả"/>
      <label>Thiết kế</label>
      <input id="design" placeholder="Tên họa sĩ/thiết kế"/>
      <label>Ảnh bìa (URL)</label>
      <input id="cover" placeholder="https://.../cover.webp"/>
    </div>

    <!-- ACTIONS -->
    <div class="section">
      <h2>Actions</h2>
      <div class="row">
        <!-- New Book: xoá sạch form và gợi ý ID kế tiếp -->
        <button class="btn" id="btnNewBook" title="Xoá sạch dữ liệu để nhập cuốn mới (tự gợi ý ID tiếp theo)">New Book</button>

        <!-- Pages -->
        <button class="btn" id="btnAddPage">Add Page</button>
        <button class="btn danger" id="btnDeletePage">Delete Page</button>
        <select id="deleteTarget" class="select" title="Chọn hình thức xóa">
          <option value="current">Trang đang chọn</option>
          <option value="last">Trang cuối</option>
        </select>

        <!-- Raw JSON -->
        <button class="btn" id="btnImport">Import JSON</button>
        <button class="btn" id="btnExport">Export JSON</button>
        <input id="fileImport" type="file" accept="application/json" style="display:none">

        <!-- Manifest toàn cuốn -->
        <button class="btn" id="btnManifest" title="Tạo manifest đầy đủ để đọc truyện">Tạo Manifest (full)</button>
        <label class="muted" style="display:flex;align-items:center;gap:6px;" title="Nối #hash vào URL cover/image/sound khi tạo manifest">
          <input type="checkbox" id="includeHash"> Thêm #hash vào URL tài nguyên
        </label>
      </div>

      <div class="hr"></div>

      <!-- LIBRARY MANIFEST -->
      <h2>Library Manifest</h2>
      <div class="row">
        <button class="btn" id="btnImportLibrary">Import Library Manifest</button>
        <button class="btn" id="btnExportLibrary">Export Library Manifest</button>
        <button class="btn" id="btnUpdateLibraryFromThisBook" title="Cập nhật/ghi đè sách đang mở (B001/B002...) vào Library; chỉ tăng version khi có thay đổi">Update Library (from current book)</button>
        <input id="fileImportLibrary" type="file" accept="application/json" style="display:none">

        <label class="muted" style="display:flex;align-items:center;gap:6px;" title="Khi bật: mỗi lần bạn Export JSON hoặc Tạo Manifest, Library sẽ tự cập nhật & tăng version nếu có thay đổi">
          <input type="checkbox" id="autoUpdateLibrary" checked>
          Auto update Library
        </label>
      </div>
    </div>

    <!-- PAGES -->
    <div class="section">
      <h2>Các Trang</h2>
      <div id="pagesContainer"></div>
    </div>

    <!-- OUTPUT -->
    <div class="section">
      <h2>Kết quả / Log</h2>
      <pre id="manifestOutput"></pre>
    </div>
  </div>

  <script>
    /* ========= Utils ========= */
    const q  = (sel, root=document) => root.querySelector(sel);
    const qa = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const genHash = () => Math.random().toString(36).slice(2,8);

    /* ========= Draft (raw editor) ========= */
    const LS_DRAFT_KEY = 'storybook_editor_draft_min';
    const saveDraft = () => localStorage.setItem(LS_DRAFT_KEY, JSON.stringify(collectAll()));
    const loadDraft = () => { try { return JSON.parse(localStorage.getItem(LS_DRAFT_KEY)||'null'); } catch { return null; } };

    /* ========= Library Manifest (nhiều cuốn) ========= */
    let libraryManifest = {
      type: "storybook.library",
      version: 1,
      updated_at: new Date().toISOString(),
      books: [] // { id, title_vi, title_en, author, design, cover, pages_count, content_hash, updated_at }
    };
    const LS_LIBRARY_KEY = 'storybook_library_manifest_min';

    // Load Library trước để có thể gợi ý ID kế tiếp
    (function loadLibraryFromStorage(){
      const raw = localStorage.getItem(LS_LIBRARY_KEY);
      if (raw) { try { libraryManifest = JSON.parse(raw); } catch {} }
    })();

    // ==== NEXT-ID SUGGESTION ====
    // Phân tích ID dạng: PREFIX + NUMBER (vd: B001, BK0007)
    function parseId(id){
      const m = String(id||'').match(/^([A-Za-z]+)(\d+)$/);
      if (!m) return null;
      return { prefix: m[1], num: parseInt(m[2], 10), width: m[2].length };
    }
    // Tìm cuốn có số lớn nhất trong library -> sinh ID kế tiếp, giữ prefix & zero-padding
    function suggestNextBookId(){
      const arr = libraryManifest.books
        .map(b => parseId(b.id))
        .filter(Boolean);
      if (!arr.length) return 'B001';
      // lấy số lớn nhất
      let best = arr[0];
      for (const r of arr) {
        if (r.num > best.num) best = r;
      }
      const nextNum = best.num + 1;
      const padded = String(nextNum).padStart(best.width, '0');
      return `${best.prefix}${padded}`;
    }

    /* ========= State trang ========= */
    let pages = [];
    let current = 0;

    function collectAll(){
      return {
        id:       q('#bookId').value.trim(),
        title_vi: q('#titleVi').value.trim(),
        title_en: q('#titleEn').value.trim(),
        author:   q('#author').value.trim(),
        design:   q('#design').value.trim(),
        cover:    q('#cover').value.trim(),
        pages:    pages.map(p=>({ ...p }))
      };
    }

    function setCurrentOptions(){
      const sel = q('#currentIndex');
      if (!sel) return;
      sel.innerHTML = pages.map((_,i)=>`<option value="${i}">#${i+1}</option>`).join('');
      sel.value = String(current);
    }

    function renderPages(){
      const wrap = q('#pagesContainer');
      wrap.innerHTML = '';

      pages.forEach((p, idx) => {
        const div = document.createElement('div');
        div.className = 'page-entry';
        div.innerHTML = `
          <div class="page-head">
            <strong>Page #${idx+1}${idx===current ? ' (đang chọn)' : ''}</strong>
            <div class="row">
              <button class="btn" data-act="up">↑</button>
              <button class="btn" data-act="down">↓</button>
              <button class="btn danger" data-act="remove">Xoá</button>
              <button class="btn" data-act="pick">Chọn</button>
            </div>
          </div>
          <div class="grid">
            <div>
              <label>TDBook</label>
              <input data-f="TDBook" placeholder="Tiêu đề trang" value="${p.TDBook||''}">
            </div>
            <div>
              <label>IDPage</label>
              <input data-f="IDPage" placeholder="VD: P001" value="${p.IDPage||''}">
            </div>
            <div>
              <label>noidung_vi</label>
              <textarea data-f="noidung_vi" placeholder="Nội dung tiếng Việt">${p.noidung_vi||''}</textarea>
            </div>
            <div>
              <label>noidung_en</label>
              <textarea data-f="noidung_en" placeholder="English content">${p.noidung_en||''}</textarea>
            </div>
            <div>
              <label>L_image_P (URL hình)</label>
              <input data-f="L_image_P" placeholder="https://.../page.webp" value="${p.L_image_P||''}">
            </div>
            <div>
              <label>L_sound_vi (URL audio VI)</label>
              <input data-f="L_sound_vi" placeholder="https://.../voice-vi.mp3" value="${p.L_sound_vi||''}">
            </div>
            <div>
              <label>L_sound_en (URL audio EN)</label>
              <input data-f="L_sound_en" placeholder="https://.../voice-en.mp3" value="${p.L_sound_en||''}">
            </div>
          </div>
        `;
        wrap.appendChild(div);

        qa('[data-f]', div).forEach(inp=>{
          inp.addEventListener('input', (e)=>{
            pages[idx][inp.dataset.f] = e.target.value;
            saveDraft();
          });
        });

        div.querySelector('[data-act="up"]').onclick = ()=>{
          if (idx===0) return;
          [pages[idx-1], pages[idx]] = [pages[idx], pages[idx-1]];
          if (current===idx) current=idx-1;
          renderPages(); setCurrentOptions(); saveDraft();
        };
        div.querySelector('[data-act="down"]').onclick = ()=>{
          if (idx===pages.length-1) return;
          [pages[idx+1], pages[idx]] = [pages[idx], pages[idx+1]];
          if (current===idx) current=idx+1;
          renderPages(); setCurrentOptions(); saveDraft();
        };
        div.querySelector('[data-act="remove"]').onclick = ()=>{
          if (!confirm(`Xoá Page #${idx+1}?`)) return;
          pages.splice(idx,1);
          if (current>=pages.length) current = Math.max(0, pages.length-1);
          renderPages(); setCurrentOptions(); saveDraft();
        };
        div.querySelector('[data-act="pick"]').onclick = ()=>{
          current = idx;
          renderPages(); setCurrentOptions(); saveDraft();
        };
      });
    }

    function emptyPage(){
      return { TDBook:"", IDPage:"", noidung_vi:"", noidung_en:"", L_image_P:"", L_sound_vi:"", L_sound_en:"" };
    }
    function addPage(){
      pages.push(emptyPage());
      current = pages.length-1;
      renderPages(); setCurrentOptions(); saveDraft();
    }
    function deletePage(){
      if (!pages.length) return;
      const mode = q('#deleteTarget').value;
      const idx = (mode==='last') ? (pages.length-1) : current;
      if (!confirm(`Xoá Page #${idx+1}?`)) return;
      pages.splice(idx,1);
      if (current>=pages.length) current = Math.max(0, pages.length-1);
      renderPages(); setCurrentOptions(); saveDraft();
    }

    /* ========= Manifest toàn cuốn + content_hash ========= */
    function normalizeBookForHash(raw) {
      return {
        id: raw.id || "",
        title_vi: raw.title_vi || "",
        title_en: raw.title_en || "",
        author: raw.author || "",
        design: raw.design || "",
        cover: raw.cover || "",
        pages: (raw.pages || []).map(p => ({
          id: p.IDPage || p.id || "",
          text_vi: p.noidung_vi || p.text_vi || "",
          text_en: p.noidung_en || p.text_en || "",
          image: p.L_image_P || p.image || "",
          sound_vi: p.L_sound_vi || p.sound_vi || "",
          sound_en: p.L_sound_en || p.sound_en || ""
        }))
      };
    }
    async function sha256Hex(str) {
      const buf = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest('SHA-256', buf);
      return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }
    async function buildWholeBookManifest(raw, {addAssetHash=false} = {}) {
      const data = structuredClone(raw);
      if (addAssetHash) {
        const addH = s => s ? (s + '#' + genHash()) : s;
        if (data.cover) data.cover = addH(data.cover);
        data.pages = data.pages.map(p=>({
          ...p,
          L_image_P: addH(p.L_image_P),
          L_sound_vi: addH(p.L_sound_vi),
          L_sound_en: addH(p.L_sound_en),
        }));
      }
      const manifest = {
        id: data.id,
        title_vi: data.title_vi,
        title_en: data.title_en,
        author: data.author,
        design: data.design,
        cover: data.cover,
        pages: data.pages.map(p=>({
          id: p.IDPage,
          text_vi: p.noidung_vi,
          text_en: p.noidung_en,
          image: p.L_image_P,
          sound_vi: p.L_sound_vi,
          sound_en: p.L_sound_en
        }))
      };
      const norm = normalizeBookForHash(raw);
      const content_hash = await sha256Hex(JSON.stringify(norm));
      return { manifest, content_hash, pages_count: norm.pages.length };
    }

    /* ========= Update Library (version tăng khi đổi) ========= */
    function findBookIndexInLibrary(bookId) {
      return libraryManifest.books.findIndex(b => (b.id || "") === (bookId || ""));
    }

    async function updateLibraryWithBook(raw){
      const { content_hash, pages_count } = await buildWholeBookManifest(raw, { addAssetHash:false });

      const entry = {
        id: raw.id || "",
        title_vi: raw.title_vi || "",
        title_en: raw.title_en || "",
        author: raw.author || "",
        design: raw.design || "",
        cover: raw.cover || "",
        pages_count,
        content_hash,
        updated_at: new Date().toISOString()
      };

      const i = findBookIndexInLibrary(entry.id);
      const now = new Date().toISOString();

      if (i === -1) {
        libraryManifest.books.push(entry);
        libraryManifest.version += 1;
        libraryManifest.updated_at = now;
        return { action: 'added', bumped: true };
      } else {
        const old = libraryManifest.books[i];
        const changed =
          old.content_hash !== entry.content_hash ||
          old.title_vi !== entry.title_vi ||
          old.title_en !== entry.title_en ||
          old.author   !== entry.author   ||
          old.design   !== entry.design   ||
          old.cover    !== entry.cover    ||
          old.pages_count !== entry.pages_count;

        if (changed) {
          libraryManifest.books[i] = entry;
          libraryManifest.version += 1;
          libraryManifest.updated_at = now;
          return { action: 'updated', bumped: true };
        } else {
          return { action: 'unchanged', bumped: false };
        }
      }
    }

    async function maybeUpdateLibraryFromCurrent(){
      const auto = q('#autoUpdateLibrary');
      if (!auto || !auto.checked) return;
      const raw = collectAll();
      if (!raw.id) return;

      const result = await updateLibraryWithBook(raw);
      localStorage.setItem(LS_LIBRARY_KEY, JSON.stringify(libraryManifest));

      // Sau khi cập nhật library, cập nhật luôn gợi ý ID kế tiếp
      nextIdHint = suggestNextBookId();

      const log = `[Library] ${raw.id}: ${result.action}. Version: v${libraryManifest.version} (bumped=${result.bumped})`;
      const pre = q('#manifestOutput');
      pre.textContent = (pre.textContent ? pre.textContent + '\n\n' : '') + log;
    }

    /* ========= Import/Export Library ========= */
    q('#btnImportLibrary').onclick = ()=> q('#fileImportLibrary').click();
    q('#fileImportLibrary').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if (!f) return;
      try {
        const text = await f.text();
        const data = JSON.parse(text);
        if (data?.type !== 'storybook.library') {
          if (!confirm('File không có type=storybook.library. Import vẫn tiếp tục?')) return;
        }
        libraryManifest = {
          type: "storybook.library",
          version: Number.isInteger(data.version) ? data.version : 1,
          updated_at: data.updated_at || new Date().toISOString(),
          books: Array.isArray(data.books) ? data.books : []
        };
        localStorage.setItem(LS_LIBRARY_KEY, JSON.stringify(libraryManifest));
        q('#manifestOutput').textContent = JSON.stringify(libraryManifest, null, 2);

        // Cập nhật gợi ý ID sau khi import
        nextIdHint = suggestNextBookId();
        alert('Đã import Library Manifest.');
      } catch(err) {
        alert('Import lỗi: ' + err.message);
      } finally { e.target.value = ""; }
    });

    q('#btnExportLibrary').onclick = ()=>{
      const json = JSON.stringify(libraryManifest, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'library-manifest-v' + (libraryManifest.version||1) + '.json';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    q('#btnUpdateLibraryFromThisBook').onclick = async ()=>{
      const raw = collectAll();
      if (!raw.id) { alert('Chưa có ID Sách. Nhập ID trước (vd: B001).'); return; }

      const result = await updateLibraryWithBook(raw);
      localStorage.setItem(LS_LIBRARY_KEY, JSON.stringify(libraryManifest));
      q('#manifestOutput').textContent = JSON.stringify(libraryManifest, null, 2);

      // cập nhật gợi ý ID mới
      nextIdHint = suggestNextBookId();

      if (result.bumped) {
        alert(`Library đã ${result.action==='added'?'thêm':'cập nhật'} ${raw.id} và tăng version lên v${libraryManifest.version}.`);
      } else {
        alert(`Không có thay đổi cho ${raw.id}. Library giữ nguyên v${libraryManifest.version}.`);
      }
    };

    /* ========= Manifest/Raw actions ========= */
    q('#btnManifest').onclick = async ()=>{
      const raw = collectAll();
      const addAssetHash = q('#includeHash').checked;
      const { manifest } = await buildWholeBookManifest(raw, { addAssetHash });
      q('#manifestOutput').textContent = JSON.stringify(manifest, null, 2);
      await maybeUpdateLibraryFromCurrent();
    };

    q('#btnExport').onclick = async ()=>{
      const json = JSON.stringify(collectAll(), null, 2);
      const blob = new Blob([json], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (q('#bookId').value || 'book') + '.json';
      a.click();
      URL.revokeObjectURL(a.href);
      await maybeUpdateLibraryFromCurrent();
    };

    q('#btnImport').onclick = ()=> q('#fileImport').click();
    q('#fileImport').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if (!f) return;
      try{
        const text = await f.text();
        const data = JSON.parse(text);

        if ('id' in data || 'title_vi' in data || 'pages' in data){
          // manifest full
          q('#bookId').value = data.id || "";
          q('#titleVi').value = data.title_vi || "";
          q('#titleEn').value = data.title_en || "";
          q('#author').value  = data.author || "";
          q('#design').value  = data.design || "";
          q('#cover').value   = data.cover || "";
          pages = Array.isArray(data.pages) ? data.pages.map(p=>({
            TDBook: "",
            IDPage: p.id || "",
            noidung_vi: p.text_vi || "",
            noidung_en: p.text_en || "",
            L_image_P: p.image || "",
            L_sound_vi: p.sound_vi || "",
            L_sound_en: p.sound_en || ""
          })) : [];
        } else {
          // raw editor
          q('#bookId').value = data.id || data.IDBook || "";
          q('#titleVi').value = data.title_vi || data.little_vi || "";
          q('#titleEn').value = data.title_en || data.little_en || "";
          q('#author').value  = data.author || data.auther || "";
          q('#design').value  = data.design || "";
          q('#cover').value   = data.cover || data.L_imageBia || "";
          pages = Array.isArray(data.pages) ? data.pages.map(p=>({
            TDBook: p.TDBook || "",
            IDPage: p.IDPage || p.id || "",
            noidung_vi: p.noidung_vi || p.text_vi || "",
            noidung_en: p.noidung_en || p.text_en || "",
            L_image_P: p.L_image_P || p.image || "",
            L_sound_vi: p.L_sound_vi || p.sound_vi || "",
            L_sound_en: p.L_sound_en || p.sound_en || ""
          })) : [];
        }

        current = 0;
        renderPages(); setCurrentOptions(); saveDraft();
      }catch(err){
        alert('Import lỗi: ' + err.message);
      } finally { e.target.value = ""; }
    });

    /* ========= New Book ========= */
    function resetBook({ askConfirm = true } = {}) {
      if (askConfirm && !confirm("Xóa hết dữ liệu hiện tại để tạo sách mới?")) return;

      // Metadata sách
      q('#bookId').value = "";
      q('#titleVi').value = "";
      q('#titleEn').value = "";
      q('#author').value  = "";
      q('#design').value  = "";
      q('#cover').value   = "";

      // 1 trang trống
      pages = [ { TDBook:"", IDPage:"", noidung_vi:"", noidung_en:"", L_image_P:"", L_sound_vi:"", L_sound_en:"" } ];
      current = 0;
      renderPages();
      setCurrentOptions();

      // Xoá draft cũ
      try { localStorage.removeItem(LS_DRAFT_KEY); } catch {}

      // Điền sẵn ID gợi ý
      q('#bookId').value = nextIdHint || suggestNextBookId();

      // Xoá log
      const pre = q('#manifestOutput');
      if (pre) pre.textContent = "";

      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    q('#btnNewBook').onclick = () => resetBook({ askConfirm: true });

    /* ========= Boot & Autosave ========= */
    // gợi ý ID toàn cục (update sau mỗi import/update library)
    let nextIdHint = suggestNextBookId();

    (function init(){
      // Nếu chưa có draft, gợi ý ID ngay; nếu có draft, giữ nguyên draft
      const draft = loadDraft();
      if (draft){
        q('#bookId').value = draft.id || "";
        q('#titleVi').value = draft.title_vi || "";
        q('#titleEn').value = draft.title_en || "";
        q('#author').value  = draft.author || "";
        q('#design').value  = draft.design || "";
        q('#cover').value   = draft.cover || "";
        pages = Array.isArray(draft.pages) ? draft.pages.map(p=>({
          TDBook: p.TDBook || "",
          IDPage: p.IDPage || p.id || "",
          noidung_vi: p.noidung_vi || p.text_vi || "",
          noidung_en: p.noidung_en || p.text_en || "",
          L_image_P: p.L_image_P || p.image || "",
          L_sound_vi: p.L_sound_vi || p.sound_vi || "",
          L_sound_en: p.L_sound_en || p.sound_en || ""
        })) : [];
      } else {
        // không có draft -> gợi ý ID kế tiếp & 1 trang trống
        q('#bookId').value = nextIdHint || 'B001';
        pages = [ { TDBook:"", IDPage:"", noidung_vi:"", noidung_en:"", L_image_P:"", L_sound_vi:"", L_sound_en:"" } ];
      }

      renderPages(); setCurrentOptions();

      // autosave cho input meta
      ['bookId','titleVi','titleEn','author','design','cover'].forEach(id=>{
        q('#'+id).addEventListener('input', saveDraft);
      });
    })();

    window.addEventListener('beforeunload', (e)=>{
      const d = collectAll();
      const hasData = d.id || d.title_vi || d.title_en || d.author || d.design || d.cover ||
                      (d.pages && d.pages.some(p => Object.values(p).some(Boolean)));
      if (hasData) { e.preventDefault(); e.returnValue = ''; }
    });
  </script>
</body>
</html>
